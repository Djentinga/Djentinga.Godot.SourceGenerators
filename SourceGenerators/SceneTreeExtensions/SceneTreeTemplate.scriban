{{-
func visible(node)
    ret node.Value.Visible
end
-}}

{{- func render_unique(node, scope) ~}}
    [EditorBrowsable(EditorBrowsableState.Never)]
    private {{node.Type}} _{{node.Name}};

    [EditorBrowsable(EditorBrowsableState.Never)]
    private Godot.NodePath _{{node.Name}}Path;

    {{scope}} {{node.Type}} {{node.Name}}
        {
            get
            {
                if (_{{node.Name}} is not null && !Godot.GodotObject.IsInstanceValid(_{{node.Name}}))
                    _{{node.Name}} = null;

                return _{{node.Name}} ??=
                    GetNode<{{node.Type}}>(_{{node.Name}}Path ??= "%{{node.Path | string.split '/' | array.last}}");
            }
        }

{{~ end -}}

{{- func render_branch(node, depth, indent) ~}}

{{indent}}        [EditorBrowsable(EditorBrowsableState.Never)]
{{indent}}        private __{{depth}}_{{node.Value.Name}} _{{depth}}_{{node.Value.Name}};

{{indent}}        public __{{depth}}_{{node.Value.Name}} {{node.Value.Name}}
{{indent}}            => _{{depth}}_{{node.Value.Name}} ??= new(_root);

{{indent}}        [EditorBrowsable(EditorBrowsableState.Never)]
{{indent}}        public class __{{depth}}_{{node.Value.Name}}
{{indent}}        {
{{indent}}            private readonly {{SceneTree.Root.Type}} _root;

{{indent}}            public __{{depth}}_{{node.Value.Name}}({{SceneTree.Root.Type}} root)
{{indent}}                => _root = root ?? throw new System.ArgumentNullException(nameof(root));

{{indent}}            [EditorBrowsable(EditorBrowsableState.Never)]
{{indent}}            private {{node.Value.Type}} _{{depth}}_{{node.Value.Name}};

{{indent}}            [EditorBrowsable(EditorBrowsableState.Never)]
{{indent}}            private Godot.NodePath _{{depth}}_{{node.Value.Name}}Path;

{{indent}}            public {{node.Value.Type}} Get()
{{indent}}            {
{{indent}}                // If cached node was freed/invalid, drop it and re-resolve.
{{indent}}                if (_{{depth}}_{{node.Value.Name}} is not null && !Godot.GodotObject.IsInstanceValid(_{{depth}}_{{node.Value.Name}}))
{{indent}}                    _{{depth}}_{{node.Value.Name}} = null;
{{indent}}
{{indent}}                return _{{depth}}_{{node.Value.Name}} ??=
{{indent}}                    _root.GetNode<{{node.Value.Type}}>(_{{depth}}_{{node.Value.Name}}Path ??= "{{node.Value.Path}}");
{{indent}}            }

{{indent}}            public static implicit operator {{node.Value.Type}}(__{{depth}}_{{node.Value.Name}} source)
{{indent}}                => source is null
{{indent}}                    ? throw new System.ArgumentNullException(nameof(source))
{{indent}}                    : source.Get();
{{~
    for child in node.Children | array.filter @visible
        render_tree child depth + 1 indent + "    "
    end
~}}
{{indent}}        }
{{~ end -}}

{{-
func render_tree(node, depth=0, indent="")
    render_branch node depth indent
end
-}}

using System.ComponentModel;

{{~ Namespace ~}}

partial class {{ClassName}}{{if !HasTscnFilePathAttribute}} : Godot.ISceneTree{{end}}
{
{{~if !HasTscnFilePathAttribute~}}
    public static string TscnFilePath { get; } = "{{TscnResource}}";
{{~end~}}

{{~
for x in UniqueNodes
    render_unique x.Node x.Scope
end
~}}
    [EditorBrowsable(EditorBrowsableState.Never)]
    private _SceneTree _sceneTree;

    private _SceneTree {{Root}} => _sceneTree ??= new(this);

    [EditorBrowsable(EditorBrowsableState.Never)]
    private class _SceneTree
    {
        private {{SceneTree.Root.Type}} _root;

        public _SceneTree({{ClassName}} source)
        {
            if (source is null)
                throw new System.ArgumentNullException(nameof(source));

            _root = GetSceneRoot(source);

            {{SceneTree.Root.Type}} GetSceneRoot(Godot.Node start)
            {
                // Do not require a specific SceneFilePath; allow inherited/instanced scenes.
                // Find the nearest ancestor that matches the expected root type.
                for (var node = start; node is not null; node = node.GetParent())
                {
                    if (node is {{SceneTree.Root.Type}} typed)
                        return typed;
                }

                var safeName = start?.Name ?? "<null>";
                Throw($"{safeName} was not under a {{SceneTree.Root.Type}} root");
                return default!; // Unreachable
            }

            static void Throw(string msg)
                => throw new System.InvalidOperationException(
                    $"Could not find scene root ({{ClassName}} can only be used within {{TscnResource}}) [Error: {msg}]");
        }

        public {{SceneTree.Root.Type}} Get()
            => _root;

        public static implicit operator {{SceneTree.Root.Type}}(_SceneTree source)
            => source is null
                ? throw new System.ArgumentNullException(nameof(source))
                : source.Get();
{{~
for node in SceneTree.Children | array.filter @visible
    render_tree node
end
~}}
    }
}
